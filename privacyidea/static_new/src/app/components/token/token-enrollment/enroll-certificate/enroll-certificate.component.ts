import {
  Component,
  EventEmitter,
  linkedSignal,
  OnInit,
  Output,
} from '@angular/core';
import { MatFormField, MatLabel } from '@angular/material/form-field';
import { MatInput } from '@angular/material/input';
import {
  FormControl,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import {
  MatButtonToggle,
  MatButtonToggleGroup,
} from '@angular/material/button-toggle';
import { ErrorStateMatcher, MatOption } from '@angular/material/core';
import { MatError, MatSelect } from '@angular/material/select';
import { CaConnectorService } from '../../../../services/ca-connector/ca-connector.service';
import {
  EnrollmentResponse,
  TokenService,
} from '../../../../services/token/token.service';

import { Observable, of } from 'rxjs';
import { TokenEnrollmentData } from '../../../../mappers/token-api-payload/_token-api-payload.mapper';
import { CertificateApiPayloadMapper } from '../../../../mappers/token-api-payload/certificate-token-api-payload.mapper';

export interface CertificateEnrollmentOptions extends TokenEnrollmentData {
  type: 'certificate';
  caConnector: string; // Keep original type
  certTemplate: string; // Keep original type
  pem?: string; // Optional, if generated by CA or provided by user
  // genkey is handled by the service
}
export class CaConnectorErrorStateMatcher implements ErrorStateMatcher {
  isErrorState(control: FormControl | null): boolean {
    const invalid = control && control.value ? control.value === '' : true;
    return !!(control && invalid && (control.dirty || control.touched));
  }
}

@Component({
  selector: 'app-enroll-certificate',
  standalone: true,
  imports: [
    MatFormField,
    MatInput,
    MatLabel,
    ReactiveFormsModule,
    MatButtonToggleGroup,
    MatButtonToggle,
    FormsModule,
    MatOption,
    MatSelect,
    MatError,
  ],
  templateUrl: './enroll-certificate.component.html',
  styleUrl: './enroll-certificate.component.scss',
})
export class EnrollCertificateComponent implements OnInit {
  text = this.tokenService
    .tokenTypeOptions()
    .find((type) => type.key === 'certificate')?.text;

  @Output() aditionalFormFieldsChange = new EventEmitter<{
    [key: string]: FormControl<any>;
  }>();
  @Output() clickEnrollChange = new EventEmitter<
    (basicOptions: TokenEnrollmentData) => Observable<EnrollmentResponse | null>
  >();

  caConnectorControl = new FormControl<string>('', [Validators.required]);
  certTemplateControl = new FormControl<string>('');
  pemControl = new FormControl<string>(''); // Validator is set dynamically
  intentionToggleControl = new FormControl<'generate' | 'upload'>('generate', [
    Validators.required,
  ]);

  certificateForm = new FormGroup({
    caConnector: this.caConnectorControl,
    certTemplate: this.certTemplateControl,
    pem: this.pemControl,
    intentionToggle: this.intentionToggleControl,
  });

  // Options for the template
  caConnectorOptions = linkedSignal({
    source: this.caConnectorService.caConnectors,
    computation: (caConnectors) =>
      typeof caConnectors === 'object'
        ? Object.values(caConnectors).map(
            (caConnector) => caConnector.connectorname,
          )
        : [],
  });

  certTemplateOptions = linkedSignal({
    source: this.caConnectorService.caConnectors,
    computation: (caConnectors) => {
      // Find the selected connector
      const selectedConnectorName = this.caConnectorControl.value;
      const selectedConnector = Object.values(caConnectors).find(
        (c) => c.connectorname === selectedConnectorName,
      );
      return selectedConnector && selectedConnector.templates
        ? Object.keys(selectedConnector.templates)
        : [];
    },
  });

  caConnectorErrorStateMatcher = new CaConnectorErrorStateMatcher();

  constructor(
    private caConnectorService: CaConnectorService,
    private tokenService: TokenService,
    private enrollmentMapper: CertificateApiPayloadMapper,
  ) {}

  ngOnInit(): void {
    this.aditionalFormFieldsChange.emit({
      caConnector: this.caConnectorControl,
      certTemplate: this.certTemplateControl,
      pem: this.pemControl,
      intentionToggle: this.intentionToggleControl,
    });
    this.clickEnrollChange.emit(this.onClickEnroll);

    this.intentionToggleControl.valueChanges.subscribe((intention) => {
      if (intention === 'upload') {
        this.pemControl.setValidators([Validators.required]);
        this.caConnectorControl.clearValidators();
        this.certTemplateControl.clearValidators();
      } else {
        this.pemControl.clearValidators();
        this.caConnectorControl.setValidators([Validators.required]);
        this.certTemplateControl.setValidators([Validators.required]);
      }
      this.pemControl.updateValueAndValidity();
      this.caConnectorControl.updateValueAndValidity();
      this.certTemplateControl.updateValueAndValidity();
    });
  }

  onClickEnroll = (
    basicOptions: TokenEnrollmentData,
  ): Observable<EnrollmentResponse | null> => {
    if (this.certificateForm.invalid) {
      this.certificateForm.markAllAsTouched();
      return of(null);
    }
    const enrollmentData: CertificateEnrollmentOptions = {
      ...basicOptions,
      type: 'certificate',
      caConnector: this.caConnectorControl.value ?? '',
      certTemplate: this.certTemplateControl.value ?? '',
    };
    if (this.intentionToggleControl.value === 'upload') {
      enrollmentData.pem = this.pemControl.value ?? '';
    }
    // 'genkey' is set server-side based on 'pem'.
    return this.tokenService.enrollToken({
      data: enrollmentData,
      mapper: this.enrollmentMapper,
    });
  };
}
